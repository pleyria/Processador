// Copyright (C) 1991-2015 Altera Corporation. All rights reserved.
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, the Altera Quartus II License Agreement,
// the Altera MegaCore Function License Agreement, or other 
// applicable license agreement, including, without limitation, 
// that your use is for the sole purpose of programming logic 
// devices manufactured by Altera and sold by Altera or its 
// authorized distributors.  Please refer to the applicable 
// agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "03/18/2020 15:36:57"
                                                                        
// Verilog Self-Checking Test Bench (with test vectors) for design :    DecodificadorInstrucoes
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module DecodificadorInstrucoes_vlg_sample_tst(
	instrucao,
	sampler_tx
);
input [15:0] instrucao;
output sampler_tx;

reg sample;
time current_time;
always @(instrucao)
                                                                                
begin                                                 
 if ($realtime > 0)                                   
 begin                                                
    if ($realtime == 0 || $realtime != current_time)  
    begin                                             
        if (sample === 1'bx)                          
            sample = 0;                               
        else                                          
            sample = ~sample;                         
    end                                               
    current_time = $realtime;                         
 end                                                  
end                                                   

assign sampler_tx = sample;
endmodule

module DecodificadorInstrucoes_vlg_check_tst (
	sADD,
	sAND,
	sDIR,
	sHLT,
	sIM,
	sIN,
	sIND,
	sJ,
	sJN,
	sJZ,
	sLDA,
	sNOP,
	sNOT,
	sOR,
	sOUT,
	sSHL,
	sSHR,
	sSOP,
	sSTA,
	sSUB,
	sampler_rx
);
input  sADD;
input  sAND;
input  sDIR;
input  sHLT;
input  sIM;
input  sIN;
input  sIND;
input  sJ;
input  sJN;
input  sJZ;
input  sLDA;
input  sNOP;
input  sNOT;
input  sOR;
input  sOUT;
input  sSHL;
input  sSHR;
input  sSOP;
input  sSTA;
input  sSUB;
input sampler_rx;

reg  sADD_expected;
reg  sAND_expected;
reg  sDIR_expected;
reg  sHLT_expected;
reg  sIM_expected;
reg  sIN_expected;
reg  sIND_expected;
reg  sJ_expected;
reg  sJN_expected;
reg  sJZ_expected;
reg  sLDA_expected;
reg  sNOP_expected;
reg  sNOT_expected;
reg  sOR_expected;
reg  sOUT_expected;
reg  sSHL_expected;
reg  sSHR_expected;
reg  sSOP_expected;
reg  sSTA_expected;
reg  sSUB_expected;

reg  sADD_prev;
reg  sAND_prev;
reg  sDIR_prev;
reg  sHLT_prev;
reg  sIM_prev;
reg  sIN_prev;
reg  sIND_prev;
reg  sJ_prev;
reg  sJN_prev;
reg  sJZ_prev;
reg  sLDA_prev;
reg  sNOP_prev;
reg  sNOT_prev;
reg  sOR_prev;
reg  sOUT_prev;
reg  sSHL_prev;
reg  sSHR_prev;
reg  sSOP_prev;
reg  sSTA_prev;
reg  sSUB_prev;

reg  sADD_expected_prev;
reg  sAND_expected_prev;
reg  sDIR_expected_prev;
reg  sHLT_expected_prev;
reg  sIM_expected_prev;
reg  sIN_expected_prev;
reg  sIND_expected_prev;
reg  sJ_expected_prev;
reg  sJN_expected_prev;
reg  sJZ_expected_prev;
reg  sLDA_expected_prev;
reg  sNOP_expected_prev;
reg  sNOT_expected_prev;
reg  sOR_expected_prev;
reg  sOUT_expected_prev;
reg  sSHL_expected_prev;
reg  sSHR_expected_prev;
reg  sSOP_expected_prev;
reg  sSTA_expected_prev;
reg  sSUB_expected_prev;

reg  last_sADD_exp;
reg  last_sAND_exp;
reg  last_sDIR_exp;
reg  last_sHLT_exp;
reg  last_sIM_exp;
reg  last_sIN_exp;
reg  last_sIND_exp;
reg  last_sJ_exp;
reg  last_sJN_exp;
reg  last_sJZ_exp;
reg  last_sLDA_exp;
reg  last_sNOP_exp;
reg  last_sNOT_exp;
reg  last_sOR_exp;
reg  last_sOUT_exp;
reg  last_sSHL_exp;
reg  last_sSHR_exp;
reg  last_sSOP_exp;
reg  last_sSTA_exp;
reg  last_sSUB_exp;

reg trigger;

integer i;
integer nummismatches;

reg [1:20] on_first_change ;


initial
begin
trigger = 0;
i = 0;
nummismatches = 0;
on_first_change = 20'b1;
end

// update real /o prevs

always @(trigger)
begin
	sADD_prev = sADD;
	sAND_prev = sAND;
	sDIR_prev = sDIR;
	sHLT_prev = sHLT;
	sIM_prev = sIM;
	sIN_prev = sIN;
	sIND_prev = sIND;
	sJ_prev = sJ;
	sJN_prev = sJN;
	sJZ_prev = sJZ;
	sLDA_prev = sLDA;
	sNOP_prev = sNOP;
	sNOT_prev = sNOT;
	sOR_prev = sOR;
	sOUT_prev = sOUT;
	sSHL_prev = sSHL;
	sSHR_prev = sSHR;
	sSOP_prev = sSOP;
	sSTA_prev = sSTA;
	sSUB_prev = sSUB;
end

// update expected /o prevs

always @(trigger)
begin
	sADD_expected_prev = sADD_expected;
	sAND_expected_prev = sAND_expected;
	sDIR_expected_prev = sDIR_expected;
	sHLT_expected_prev = sHLT_expected;
	sIM_expected_prev = sIM_expected;
	sIN_expected_prev = sIN_expected;
	sIND_expected_prev = sIND_expected;
	sJ_expected_prev = sJ_expected;
	sJN_expected_prev = sJN_expected;
	sJZ_expected_prev = sJZ_expected;
	sLDA_expected_prev = sLDA_expected;
	sNOP_expected_prev = sNOP_expected;
	sNOT_expected_prev = sNOT_expected;
	sOR_expected_prev = sOR_expected;
	sOUT_expected_prev = sOUT_expected;
	sSHL_expected_prev = sSHL_expected;
	sSHR_expected_prev = sSHR_expected;
	sSOP_expected_prev = sSOP_expected;
	sSTA_expected_prev = sSTA_expected;
	sSUB_expected_prev = sSUB_expected;
end



// expected sADD
initial
begin
	sADD_expected = 1'bX;
end 

// expected sAND
initial
begin
	sAND_expected = 1'bX;
end 

// expected sDIR
initial
begin
	sDIR_expected = 1'bX;
end 

// expected sHLT
initial
begin
	sHLT_expected = 1'bX;
end 

// expected sIM
initial
begin
	sIM_expected = 1'bX;
end 

// expected sIN
initial
begin
	sIN_expected = 1'bX;
end 

// expected sIND
initial
begin
	sIND_expected = 1'bX;
end 

// expected sJ
initial
begin
	sJ_expected = 1'bX;
end 

// expected sJN
initial
begin
	sJN_expected = 1'bX;
end 

// expected sJZ
initial
begin
	sJZ_expected = 1'bX;
end 

// expected sLDA
initial
begin
	sLDA_expected = 1'bX;
end 

// expected sNOP
initial
begin
	sNOP_expected = 1'bX;
end 

// expected sNOT
initial
begin
	sNOT_expected = 1'bX;
end 

// expected sOR
initial
begin
	sOR_expected = 1'bX;
end 

// expected sOUT
initial
begin
	sOUT_expected = 1'bX;
end 

// expected sSHL
initial
begin
	sSHL_expected = 1'bX;
end 

// expected sSHR
initial
begin
	sSHR_expected = 1'bX;
end 

// expected sSOP
initial
begin
	sSOP_expected = 1'bX;
end 

// expected sSTA
initial
begin
	sSTA_expected = 1'bX;
end 

// expected sSUB
initial
begin
	sSUB_expected = 1'bX;
end 
// generate trigger
always @(sADD_expected or sADD or sAND_expected or sAND or sDIR_expected or sDIR or sHLT_expected or sHLT or sIM_expected or sIM or sIN_expected or sIN or sIND_expected or sIND or sJ_expected or sJ or sJN_expected or sJN or sJZ_expected or sJZ or sLDA_expected or sLDA or sNOP_expected or sNOP or sNOT_expected or sNOT or sOR_expected or sOR or sOUT_expected or sOUT or sSHL_expected or sSHL or sSHR_expected or sSHR or sSOP_expected or sSOP or sSTA_expected or sSTA or sSUB_expected or sSUB)
begin
	trigger <= ~trigger;
end

always @(posedge sampler_rx or negedge sampler_rx)
begin
`ifdef debug_tbench
	$display("Scanning pattern %d @time = %t",i,$realtime );
	i = i + 1;
	$display("| expected sADD = %b | expected sAND = %b | expected sDIR = %b | expected sHLT = %b | expected sIM = %b | expected sIN = %b | expected sIND = %b | expected sJ = %b | expected sJN = %b | expected sJZ = %b | expected sLDA = %b | expected sNOP = %b | expected sNOT = %b | expected sOR = %b | expected sOUT = %b | expected sSHL = %b | expected sSHR = %b | expected sSOP = %b | expected sSTA = %b | expected sSUB = %b | ",sADD_expected_prev,sAND_expected_prev,sDIR_expected_prev,sHLT_expected_prev,sIM_expected_prev,sIN_expected_prev,sIND_expected_prev,sJ_expected_prev,sJN_expected_prev,sJZ_expected_prev,sLDA_expected_prev,sNOP_expected_prev,sNOT_expected_prev,sOR_expected_prev,sOUT_expected_prev,sSHL_expected_prev,sSHR_expected_prev,sSOP_expected_prev,sSTA_expected_prev,sSUB_expected_prev);
	$display("| real sADD = %b | real sAND = %b | real sDIR = %b | real sHLT = %b | real sIM = %b | real sIN = %b | real sIND = %b | real sJ = %b | real sJN = %b | real sJZ = %b | real sLDA = %b | real sNOP = %b | real sNOT = %b | real sOR = %b | real sOUT = %b | real sSHL = %b | real sSHR = %b | real sSOP = %b | real sSTA = %b | real sSUB = %b | ",sADD_prev,sAND_prev,sDIR_prev,sHLT_prev,sIM_prev,sIN_prev,sIND_prev,sJ_prev,sJN_prev,sJZ_prev,sLDA_prev,sNOP_prev,sNOT_prev,sOR_prev,sOUT_prev,sSHL_prev,sSHR_prev,sSOP_prev,sSTA_prev,sSUB_prev);
`endif
	if (
		( sADD_expected_prev !== 1'bx ) && ( sADD_prev !== sADD_expected_prev )
		&& ((sADD_expected_prev !== last_sADD_exp) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sADD :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sADD_expected_prev);
		$display ("     Real value = %b", sADD_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_sADD_exp = sADD_expected_prev;
	end
	if (
		( sAND_expected_prev !== 1'bx ) && ( sAND_prev !== sAND_expected_prev )
		&& ((sAND_expected_prev !== last_sAND_exp) ||
			on_first_change[2])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sAND :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sAND_expected_prev);
		$display ("     Real value = %b", sAND_prev);
		nummismatches = nummismatches + 1;
		on_first_change[2] = 1'b0;
		last_sAND_exp = sAND_expected_prev;
	end
	if (
		( sDIR_expected_prev !== 1'bx ) && ( sDIR_prev !== sDIR_expected_prev )
		&& ((sDIR_expected_prev !== last_sDIR_exp) ||
			on_first_change[3])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sDIR :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sDIR_expected_prev);
		$display ("     Real value = %b", sDIR_prev);
		nummismatches = nummismatches + 1;
		on_first_change[3] = 1'b0;
		last_sDIR_exp = sDIR_expected_prev;
	end
	if (
		( sHLT_expected_prev !== 1'bx ) && ( sHLT_prev !== sHLT_expected_prev )
		&& ((sHLT_expected_prev !== last_sHLT_exp) ||
			on_first_change[4])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sHLT :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sHLT_expected_prev);
		$display ("     Real value = %b", sHLT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[4] = 1'b0;
		last_sHLT_exp = sHLT_expected_prev;
	end
	if (
		( sIM_expected_prev !== 1'bx ) && ( sIM_prev !== sIM_expected_prev )
		&& ((sIM_expected_prev !== last_sIM_exp) ||
			on_first_change[5])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sIM :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sIM_expected_prev);
		$display ("     Real value = %b", sIM_prev);
		nummismatches = nummismatches + 1;
		on_first_change[5] = 1'b0;
		last_sIM_exp = sIM_expected_prev;
	end
	if (
		( sIN_expected_prev !== 1'bx ) && ( sIN_prev !== sIN_expected_prev )
		&& ((sIN_expected_prev !== last_sIN_exp) ||
			on_first_change[6])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sIN :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sIN_expected_prev);
		$display ("     Real value = %b", sIN_prev);
		nummismatches = nummismatches + 1;
		on_first_change[6] = 1'b0;
		last_sIN_exp = sIN_expected_prev;
	end
	if (
		( sIND_expected_prev !== 1'bx ) && ( sIND_prev !== sIND_expected_prev )
		&& ((sIND_expected_prev !== last_sIND_exp) ||
			on_first_change[7])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sIND :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sIND_expected_prev);
		$display ("     Real value = %b", sIND_prev);
		nummismatches = nummismatches + 1;
		on_first_change[7] = 1'b0;
		last_sIND_exp = sIND_expected_prev;
	end
	if (
		( sJ_expected_prev !== 1'bx ) && ( sJ_prev !== sJ_expected_prev )
		&& ((sJ_expected_prev !== last_sJ_exp) ||
			on_first_change[8])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sJ :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sJ_expected_prev);
		$display ("     Real value = %b", sJ_prev);
		nummismatches = nummismatches + 1;
		on_first_change[8] = 1'b0;
		last_sJ_exp = sJ_expected_prev;
	end
	if (
		( sJN_expected_prev !== 1'bx ) && ( sJN_prev !== sJN_expected_prev )
		&& ((sJN_expected_prev !== last_sJN_exp) ||
			on_first_change[9])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sJN :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sJN_expected_prev);
		$display ("     Real value = %b", sJN_prev);
		nummismatches = nummismatches + 1;
		on_first_change[9] = 1'b0;
		last_sJN_exp = sJN_expected_prev;
	end
	if (
		( sJZ_expected_prev !== 1'bx ) && ( sJZ_prev !== sJZ_expected_prev )
		&& ((sJZ_expected_prev !== last_sJZ_exp) ||
			on_first_change[10])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sJZ :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sJZ_expected_prev);
		$display ("     Real value = %b", sJZ_prev);
		nummismatches = nummismatches + 1;
		on_first_change[10] = 1'b0;
		last_sJZ_exp = sJZ_expected_prev;
	end
	if (
		( sLDA_expected_prev !== 1'bx ) && ( sLDA_prev !== sLDA_expected_prev )
		&& ((sLDA_expected_prev !== last_sLDA_exp) ||
			on_first_change[11])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sLDA :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sLDA_expected_prev);
		$display ("     Real value = %b", sLDA_prev);
		nummismatches = nummismatches + 1;
		on_first_change[11] = 1'b0;
		last_sLDA_exp = sLDA_expected_prev;
	end
	if (
		( sNOP_expected_prev !== 1'bx ) && ( sNOP_prev !== sNOP_expected_prev )
		&& ((sNOP_expected_prev !== last_sNOP_exp) ||
			on_first_change[12])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sNOP :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sNOP_expected_prev);
		$display ("     Real value = %b", sNOP_prev);
		nummismatches = nummismatches + 1;
		on_first_change[12] = 1'b0;
		last_sNOP_exp = sNOP_expected_prev;
	end
	if (
		( sNOT_expected_prev !== 1'bx ) && ( sNOT_prev !== sNOT_expected_prev )
		&& ((sNOT_expected_prev !== last_sNOT_exp) ||
			on_first_change[13])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sNOT :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sNOT_expected_prev);
		$display ("     Real value = %b", sNOT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[13] = 1'b0;
		last_sNOT_exp = sNOT_expected_prev;
	end
	if (
		( sOR_expected_prev !== 1'bx ) && ( sOR_prev !== sOR_expected_prev )
		&& ((sOR_expected_prev !== last_sOR_exp) ||
			on_first_change[14])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sOR :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sOR_expected_prev);
		$display ("     Real value = %b", sOR_prev);
		nummismatches = nummismatches + 1;
		on_first_change[14] = 1'b0;
		last_sOR_exp = sOR_expected_prev;
	end
	if (
		( sOUT_expected_prev !== 1'bx ) && ( sOUT_prev !== sOUT_expected_prev )
		&& ((sOUT_expected_prev !== last_sOUT_exp) ||
			on_first_change[15])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sOUT :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sOUT_expected_prev);
		$display ("     Real value = %b", sOUT_prev);
		nummismatches = nummismatches + 1;
		on_first_change[15] = 1'b0;
		last_sOUT_exp = sOUT_expected_prev;
	end
	if (
		( sSHL_expected_prev !== 1'bx ) && ( sSHL_prev !== sSHL_expected_prev )
		&& ((sSHL_expected_prev !== last_sSHL_exp) ||
			on_first_change[16])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sSHL :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sSHL_expected_prev);
		$display ("     Real value = %b", sSHL_prev);
		nummismatches = nummismatches + 1;
		on_first_change[16] = 1'b0;
		last_sSHL_exp = sSHL_expected_prev;
	end
	if (
		( sSHR_expected_prev !== 1'bx ) && ( sSHR_prev !== sSHR_expected_prev )
		&& ((sSHR_expected_prev !== last_sSHR_exp) ||
			on_first_change[17])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sSHR :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sSHR_expected_prev);
		$display ("     Real value = %b", sSHR_prev);
		nummismatches = nummismatches + 1;
		on_first_change[17] = 1'b0;
		last_sSHR_exp = sSHR_expected_prev;
	end
	if (
		( sSOP_expected_prev !== 1'bx ) && ( sSOP_prev !== sSOP_expected_prev )
		&& ((sSOP_expected_prev !== last_sSOP_exp) ||
			on_first_change[18])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sSOP :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sSOP_expected_prev);
		$display ("     Real value = %b", sSOP_prev);
		nummismatches = nummismatches + 1;
		on_first_change[18] = 1'b0;
		last_sSOP_exp = sSOP_expected_prev;
	end
	if (
		( sSTA_expected_prev !== 1'bx ) && ( sSTA_prev !== sSTA_expected_prev )
		&& ((sSTA_expected_prev !== last_sSTA_exp) ||
			on_first_change[19])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sSTA :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sSTA_expected_prev);
		$display ("     Real value = %b", sSTA_prev);
		nummismatches = nummismatches + 1;
		on_first_change[19] = 1'b0;
		last_sSTA_exp = sSTA_expected_prev;
	end
	if (
		( sSUB_expected_prev !== 1'bx ) && ( sSUB_prev !== sSUB_expected_prev )
		&& ((sSUB_expected_prev !== last_sSUB_exp) ||
			on_first_change[20])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port sSUB :: @time = %t",  $realtime);
		$display ("     Expected value = %b", sSUB_expected_prev);
		$display ("     Real value = %b", sSUB_prev);
		nummismatches = nummismatches + 1;
		on_first_change[20] = 1'b0;
		last_sSUB_exp = sSUB_expected_prev;
	end

	trigger <= ~trigger;
end
initial 

begin 
$timeformat(-12,3," ps",6);
#1000000;
if (nummismatches > 0)
	$display ("%d mismatched vectors : Simulation failed !",nummismatches);
else
	$display ("Simulation passed !");
$finish;
end 
endmodule

module DecodificadorInstrucoes_vlg_vec_tst();
// constants                                           
// general purpose registers
reg [15:0] instrucao;
// wires                                               
wire sADD;
wire sAND;
wire sDIR;
wire sHLT;
wire sIM;
wire sIN;
wire sIND;
wire sJ;
wire sJN;
wire sJZ;
wire sLDA;
wire sNOP;
wire sNOT;
wire sOR;
wire sOUT;
wire sSHL;
wire sSHR;
wire sSOP;
wire sSTA;
wire sSUB;

wire sampler;                             

// assign statements (if any)                          
DecodificadorInstrucoes i1 (
// port map - connection between master ports and signals/registers   
	.instrucao(instrucao),
	.sADD(sADD),
	.sAND(sAND),
	.sDIR(sDIR),
	.sHLT(sHLT),
	.sIM(sIM),
	.sIN(sIN),
	.sIND(sIND),
	.sJ(sJ),
	.sJN(sJN),
	.sJZ(sJZ),
	.sLDA(sLDA),
	.sNOP(sNOP),
	.sNOT(sNOT),
	.sOR(sOR),
	.sOUT(sOUT),
	.sSHL(sSHL),
	.sSHR(sSHR),
	.sSOP(sSOP),
	.sSTA(sSTA),
	.sSUB(sSUB)
);
// instrucao[ 15 ]
initial
begin
	instrucao[15] = 1'b0;
end 
// instrucao[ 14 ]
initial
begin
	instrucao[14] = 1'b0;
end 
// instrucao[ 13 ]
initial
begin
	instrucao[13] = 1'b0;
end 
// instrucao[ 12 ]
initial
begin
	instrucao[12] = 1'b1;
end 
// instrucao[ 11 ]
initial
begin
	instrucao[11] = 1'b0;
end 
// instrucao[ 10 ]
initial
begin
	instrucao[10] = 1'b1;
end 
// instrucao[ 9 ]
initial
begin
	instrucao[9] = 1'b0;
end 
// instrucao[ 8 ]
initial
begin
	instrucao[8] = 1'b0;
end 
// instrucao[ 7 ]
initial
begin
	instrucao[7] = 1'b0;
end 
// instrucao[ 6 ]
initial
begin
	instrucao[6] = 1'b0;
end 
// instrucao[ 5 ]
initial
begin
	instrucao[5] = 1'b0;
end 
// instrucao[ 4 ]
initial
begin
	instrucao[4] = 1'b0;
end 
// instrucao[ 3 ]
initial
begin
	instrucao[3] = 1'b0;
end 
// instrucao[ 2 ]
initial
begin
	instrucao[2] = 1'b0;
end 
// instrucao[ 1 ]
initial
begin
	instrucao[1] = 1'b0;
end 
// instrucao[ 0 ]
initial
begin
	instrucao[0] = 1'b0;
end 

DecodificadorInstrucoes_vlg_sample_tst tb_sample (
	.instrucao(instrucao),
	.sampler_tx(sampler)
);

DecodificadorInstrucoes_vlg_check_tst tb_out(
	.sADD(sADD),
	.sAND(sAND),
	.sDIR(sDIR),
	.sHLT(sHLT),
	.sIM(sIM),
	.sIN(sIN),
	.sIND(sIND),
	.sJ(sJ),
	.sJN(sJN),
	.sJZ(sJZ),
	.sLDA(sLDA),
	.sNOP(sNOP),
	.sNOT(sNOT),
	.sOR(sOR),
	.sOUT(sOUT),
	.sSHL(sSHL),
	.sSHR(sSHR),
	.sSOP(sSOP),
	.sSTA(sSTA),
	.sSUB(sSUB),
	.sampler_rx(sampler)
);
endmodule

